const open = require("open");
const path = require("path");
const express = require("express");
const mercadopago = require("mercadopago");
require("dotenv").config();


const mercadoPagoPublicKey = process.env.MERCADO_PAGO_SAMPLE_PUBLIC_KEY;
if (!mercadoPagoPublicKey) {
  console.log("Error: public key not defined");
  process.exit(1);
}

const mercadoPagoAccessToken = process.env.MERCADO_PAGO_SAMPLE_ACCESS_TOKEN;
if (!mercadoPagoAccessToken) {
  console.log("Error: access token not defined");
  process.exit(1);
}

const client = new mercadopago.MercadoPagoConfig({
  accessToken: mercadoPagoAccessToken,
});




const connectDB = require("./config/database");
const authController = require("./controllers/authController");
const authMiddleware = require("./middleware/authMiddleware");
const User = require("./models/User");
const Transaction = require("./models/Transaction");
const cors = require("cors");

connectDB();

const app = express();
app.use(cors());

app.use(express.urlencoded({ extended: false }));
// app.use(express.static("./static")); // Static files removed
app.use(express.json());

// Auth Routes
/**
 * POST /auth/register
 * Register a new user.
 */
app.post("/auth/register", authController.register);

/**
 * POST /auth/login
 * Login and retrieve JWT.
 */
app.post("/auth/login", authController.login);

// Root route removed as web frontend is deleted
app.get("/", function (req, res) {
  res.status(200).send("Motomuv API Server is running.");
});

/**
 * GET /get_transactions
 * Retrieve transaction history for the authenticated user.
 * Protected by authMiddleware.
 */
app.get("/get_transactions", authMiddleware, async (req, res) => {
  try {
    const transactions = await Transaction.find({ user: req.user.userId }).sort({ date: -1 });
    res.json({ transactions });
  } catch (err) {
    console.error(err);
    res.status(500).send("Server Error");
  }
});

/**
 * GET /get_balance
 * Retrieve current balance for the authenticated user.
 * Protected by authMiddleware.
 */
app.get("/get_balance", authMiddleware, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    res.json({ balance: user.balance });
  } catch (err) {
    console.error(err);
    res.status(500).send("Server Error");
  }
});


/**
 * POST /process_payment
 * Processes a payment via Mercado Pago.
 * Supports both Credit Cards (with Token) and Yape (QR).
 * 
 * Flow:
 * 1. Receives payment details (amount, token, method, payer info).
 * 2. Checks environment (Sandbox vs Prod) to set payer email.
 * 3. Constructs the Mercado Pago payment payload.
 * 4. Calls Mercado Pago API to create payment.
 * 5. If approved, updates user balance and saves transaction.
 * 6. Returns payment status and QR code (if applicable).
 */
app.post("/process_payment", (req, res) => {
  const { body } = req;
  const { payer } = body;

  const payment = new mercadopago.Payment(client);

  // Check if we are in Sandbox (Test) environment
  const isSandbox = mercadoPagoAccessToken.startsWith("TEST-");
  const payerEmail = isSandbox ? "test_user@testuser.com" : payer.email;

  let paymentData = {
    transaction_amount: Number(body.transactionAmount),
    description: body.description,
    payment_method_id: body.paymentMethodId,
    payer: {
      email: payerEmail,
    },
  };

  if (body.paymentMethodId !== 'yape' && body.paymentMethodId !== 'pagoefectivo_atm') {
    paymentData = {
      ...paymentData,
      token: body.token,
      installments: Number(body.installments),
      issuer_id: body.issuerId,
      payer: {
        ...paymentData.payer,
        identification: {
          type: payer.identification.docType,
          number: payer.identification.docNumber,
        },
      },
    };
  } else if (body.paymentMethodId === 'yape') {
    // Yape requires token but NO issuer/installments/identification
    paymentData = {
      ...paymentData,
      token: body.token, // Add the token generated by SDK
      installments: 1 // Yape is always 1 installment
    }
  }



  console.log("Payment Data: ", paymentData);
  payment
    .create({ body: paymentData })
    .then(async function (data) {
      console.log("Payment Response: ", data);
      const responseData = {
        detail: data.status_detail,
        status: data.status,
        id: data.id,
      };

      if (data.status === 'approved') {
        try {
          // Update User Balance
          const user = await User.findOne({ email: payer.email });
          if (user) {
            user.balance += Number(paymentData.transaction_amount);
            await user.save();
            console.log(`Payment approved! New balance for ${payer.email}: ${user.balance}`);

            // Save Transaction
            const transaction = new Transaction({
              user: user._id,
              type: 'payment',
              amount: Number(paymentData.transaction_amount),
              description: body.description || 'Payment',
              status: 'approved',
              paymentMethodId: body.paymentMethodId
            });
            await transaction.save();

          } else {
            console.log(`User not found for email ${payer.email}, balance not updated.`);
          }
        } catch (err) {
          console.error("Error updating balance/transaction:", err);
        }
      }

      if (data.point_of_interaction && data.point_of_interaction.transaction_data) {
        responseData.qr_code_base64 = data.point_of_interaction.transaction_data.qr_code_base64;
        responseData.qr_code = data.point_of_interaction.transaction_data.qr_code;
      }

      if (data.transaction_details && data.transaction_details.external_resource_url) {
        responseData.external_resource_url = data.transaction_details.external_resource_url;
      }

      res.status(201).json(responseData);
    })
    .catch(function (error) {
      console.log(error);
      const { errorMessage, errorStatus } = validateError(error);
      res.status(errorStatus).json({ error_message: errorMessage });
    });
});

function validateError(error) {
  let errorMessage = "Unknown error cause";
  let errorStatus = 400;

  if (error.cause && Array.isArray(error.cause) && error.cause.length > 0) {
    const sdkErrorMessage = error.cause[0].description;
    errorMessage = sdkErrorMessage || errorMessage;
  } else if (error.message) {
    errorMessage = error.message;
  }

  if (error.status) {
    errorStatus = error.status;
  }

  return { errorMessage, errorStatus };
}

app.listen(8080, () => {
  console.log("The server is now running on port 8080");
  open("http://localhost:8080");
});
